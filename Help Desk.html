<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive Help Desk Dashboard</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/wordcloud@1.1.0/src/wordcloud2.min.js"></script>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 20px;
    background: #e6f0ff;
    color: #0a0a23;
  }

  h1 {
    text-align: center;
    margin-bottom: 30px;
    font-weight: 700;
  }

  #dashboard-container {
    background: rgba(255, 255, 255, 0.15);
    border-radius: 16px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 20px 30px 40px 30px;
    max-width: 1200px;
    margin: 0 auto 60px auto;
  }

  #file-upload-section {
    margin-bottom: 20px;
    text-align: center;
  }

  .filter-section {
    margin-bottom: 25px;
    text-align: center;
  }
  .filter-section label {
    margin-right: 10px;
    font-weight: 600;
  }
  .filter-section select,
  .filter-section input[type="date"] {
    margin-right: 20px;
    padding: 6px 10px;
    border-radius: 8px;
    border: 1.5px solid #b0c4de;
    font-size: 0.9rem;
    background: rgba(255 255 255 / 0.7);
    transition: border-color 0.3s ease;
  }
  .filter-section select:hover,
  .filter-section input[type="date"]:hover,
  .filter-section select:focus,
  .filter-section input[type="date"]:focus {
    border-color: #5599ff;
    outline: none;
    background: rgba(255 255 255 / 0.9);
  }

  #charts {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 30px;
  }

  #charts > div {
    flex: 0 0 40%;
    min-width: 320px;
    height: 350px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.25);
    box-shadow: 0 4px 20px rgb(0 0 0 / 0.1);
    padding: 15px;
    position: relative;
  }

  #wordCloud {
    height: 350px !important;
  }

  #sentimentAnalysis,
  #wordCloud {
    flex: 0 0 28%;
    min-width: 280px;
  }

  #takeaways {
    background: rgba(255, 255, 255, 0.25);
    border-radius: 16px;
    box-shadow: 0 6px 30px 0 rgba(31, 38, 135, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.4);
    max-width: 900px;
    margin: 40px auto 80px auto;
    padding: 25px 30px;
    font-size: 1rem;
    color: #072146;
  }

  #takeaways h2 {
    margin-bottom: 15px;
    font-weight: 700;
    text-align: center;
  }

  #takeaways ul {
    list-style-type: disc;
    margin-left: 20px;
  }

  @media (max-width: 900px) {
    #charts > div,
    #sentimentAnalysis,
    #wordCloud {
      flex: 0 0 90%;
      height: 320px;
    }
  }
</style>
</head>
<body>

<h1>Help Desk Performance Dashboard</h1>

<div id="dashboard-container">

  <div id="file-upload-section">
    <label for="fileInput"><strong>Upload JSON File:</strong></label>
    <input type="file" id="fileInput" accept=".json" />
  </div>

  <div class="filter-section" id="filters" style="display:none;">
    <label for="agentFilter">Agent:</label>
    <select id="agentFilter"><option value="all">All</option></select>

    <label for="lhFilter">Patient LH:</label>
    <select id="lhFilter"><option value="all">All</option></select>

    <label for="topicFilter">Topic:</label>
    <select id="topicFilter"><option value="all">All</option></select>

    <label for="dateFrom">From:</label>
    <input type="date" id="dateFrom" />

    <label for="dateTo">To:</label>
    <input type="date" id="dateTo" />
  </div>

  <div id="charts" style="display:none;">
    <div id="callsOverTime"></div>
    <div id="averageCallDurationByAgent"></div>
    <div id="callsByAgent"></div>
    <div id="callsByTopic"></div>
    <div id="callsByProduct"></div>
    <div id="callOutcomes"></div>
    <div id="sentimentAnalysis"></div>
    <div id="wordCloud"></div>
  </div>

</div>

<div id="takeaways" style="display:none;">
  <h2>Key Takeaways & Recommendations</h2>
  <ul id="takeaways-list"></ul>
</div>

<script>
// Sentiment dictionary for scoring
const sentimentDict = {
  "good": 2,
  "great": 3,
  "excellent": 3,
  "positive": 2,
  "happy": 2,
  "helpful": 2,
  "bad": -2,
  "poor": -2,
  "problem": -2,
  "issue": -2,
  "fail": -3,
  "unable": -2,
  "error": -3,
  "not": -1,
  "delay": -2,
  "confused": -2,
  "difficult": -2,
  "need": -1,
  "resource": 1,
  "request": 1
};

function simpleSentiment(text) {
  if (!text) return 0;
  const words = text.toLowerCase().match(/\b\w+\b/g);
  if (!words) return 0;
  let score = 0;
  words.forEach(word => {
    if (sentimentDict[word]) score += sentimentDict[word];
  });
  return score;
}

function parseDate(dateStr) {
  if (!dateStr) return null;
  const parts = dateStr.split(" ");
  if(parts.length < 2) return null;
  const dateParts = parts[0].split("/");
  const timeParts = parts[1].split(":");
  if(dateParts.length < 3) return null;
  const month = parseInt(dateParts[0],10) -1;
  const day = parseInt(dateParts[1],10);
  const year = parseInt(dateParts[2],10);
  const hour = parseInt(timeParts[0],10);
  const min = parseInt(timeParts[1],10);
  return new Date(year, month, day, hour, min);
}

function timeDiffMinutes(startStr, endStr) {
  const start = parseDate(startStr);
  const end = parseDate(endStr);
  if (!start || !end) return null;
  return (end - start) / 60000;
}

function uniqueValues(arr) {
  return [...new Set(arr)].sort();
}

function populateFilterOptions(data) {
  const agents = uniqueValues(data.map(d => d.Name).filter(Boolean));
  const lhs = uniqueValues(data.map(d => d["Patient LH:"]).filter(Boolean));
  let topicsRaw = [];
  data.forEach(d => {
    if(d["Call topic (select all that apply)"]) {
      topicsRaw.push(...d["Call topic (select all that apply)"].split(/[,;]/).map(t => t.trim()));
    }
  });
  const topics = uniqueValues(topicsRaw);

  const agentFilter = document.getElementById('agentFilter');
  agents.forEach(a => {
    const opt = document.createElement('option');
    opt.value = a;
    opt.text = a;
    agentFilter.appendChild(opt);
  });

  const lhFilter = document.getElementById('lhFilter');
  lhs.forEach(lh => {
    const opt = document.createElement('option');
    opt.value = lh;
    opt.text = lh;
    lhFilter.appendChild(opt);
  });

  const topicFilter = document.getElementById('topicFilter');
  topics.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t;
    opt.text = t;
    topicFilter.appendChild(opt);
  });
}

function filterData(data, filters) {
  return data.filter(d => {
    if(filters.agent !== 'all' && d.Name !== filters.agent) return false;
    if(filters.lh !== 'all' && d["Patient LH:"] !== filters.lh) return false;
    if(filters.topic !== 'all') {
      const topics = d["Call topic (select all that apply)"];
      if(!topics) return false;
      const topicsArray = topics.split(/[,;]/).map(t => t.trim());
      if(!topicsArray.includes(filters.topic)) return false;
    }
    const startDate = parseDate(d["Start time"]);
    if(!startDate) return false;
    if(filters.dateFrom && startDate < filters.dateFrom) return false;
    if(filters.dateTo && startDate > filters.dateTo) return false;
    return true;
  });
}

function aggregateCallsOverTime(data) {
  const counts = {};
  data.forEach(d => {
    const dt = parseDate(d["Start time"]);
    if(!dt) return;
    const dayKey = dt.toISOString().slice(0,10);
    counts[dayKey] = (counts[dayKey] || 0) + 1;
  });
  const dates = Object.keys(counts).sort();
  const values = dates.map(d => counts[d]);
  return {dates, values};
}

function aggregateAverageCallDurationByAgent(data) {
  const totals = {};
  const counts = {};
  data.forEach(d => {
    const agent = d.Name || "Unknown";
    const dur = timeDiffMinutes(d["Start time"], d["Completion time"]);
    if(dur !== null && dur >= 0) {
      totals[agent] = (totals[agent] || 0) + dur;
      counts[agent] = (counts[agent] || 0) + 1;
    }
  });
  const agents = Object.keys(totals).sort();
  const averages = agents.map(agent => counts[agent] ? totals[agent] / counts[agent] : 0);
  return {agents, averages};
}

function aggregateCallsByAgent(data) {
  const counts = {};
  data.forEach(d => {
    const agent = d.Name || "Unknown";
    counts[agent] = (counts[agent] || 0) + 1;
  });
  const agents = Object.keys(counts).sort();
  const values = agents.map(a => counts[a]);
  return {agents, values};
}

function aggregateCallsByTopic(data) {
  const counts = {};
  data.forEach(d => {
    const topics = d["Call topic (select all that apply)"];
    if(!topics) return;
    topics.split(/[,;]/).map(t => t.trim()).forEach(t => {
      counts[t] = (counts[t] || 0) + 1;
    });
  });
  const topics = Object.keys(counts).sort();
  const values = topics.map(t => counts[t]);
  return {topics, values, counts};
}

function aggregateCallOutcomes(data) {
  const counts = {};
  data.forEach(d => {
    const outcomes = d["What was the outcome of the call? (Select all that apply)"];
    if(!outcomes) return;
    outcomes.split(/[,;]/).map(t => t.trim()).forEach(t => {
      counts[t] = (counts[t] || 0) + 1;
    });
  });
  const outcomes = Object.keys(counts).sort();
  const values = outcomes.map(o => counts[o]);
  return {outcomes, values};
}

function aggregateCallsByProduct(data) {
  const counts = {};
  data.forEach(d => {
    const prod = d.Product || "Unknown";
    counts[prod] = (counts[prod] || 0) + 1;
  });
  const products = Object.keys(counts).sort();
  const values = products.map(p => counts[p]);
  return {products, values};
}

function aggregateSentiment(data) {
  const sentimentCounts = {Positive: 0, Neutral: 0, Negative: 0};
  data.forEach(d => {
    const text = (d["Please add a brief summary of the reason for the call:"] || "") + " " +
                 (d["Anything else you'd like to share about the call? (Ex. is there an additional resource that needs to be created, is there a new type of issue brewing, etc.)"] || "");
    const score = simpleSentiment(text);
    if(score > 0) sentimentCounts.Positive++;
    else if(score < 0) sentimentCounts.Negative++;
    else sentimentCounts.Neutral++;
  });
  return sentimentCounts;
}

function drawWordCloud(data) {
  // Aggregate topics with counts
  const topicCounts = {};
  data.forEach(d => {
    const topics = d["Call topic (select all that apply)"];
    if(!topics) return;
    topics.split(/[,;]/).map(t => t.trim()).forEach(t => {
      if(t.length > 0) topicCounts[t] = (topicCounts[t] || 0) + 1;
    });
  });

  // Convert to array suitable for WordCloud2.js: [ [word, weight], ... ]
  const wordArray = Object.entries(topicCounts);

  const wcDiv = document.getElementById('wordCloud');
  wcDiv.innerHTML = '';

  if(wordArray.length === 0) {
    wcDiv.innerHTML = '<p style="text-align:center; margin-top: 140px; color:#555;">No topics to display</p>';
    return;
  }

  WordCloud(wcDiv, {
    list: wordArray,
    gridSize: Math.round(16 * wcDiv.offsetWidth / 1024),
    weightFactor: function (size) {
      return size * 8; // scale factor for font size
    },
    fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
    color: '#1761a0',
    backgroundColor: 'rgba(255,255,255,0)',
    rotateRatio: 0.3,
    rotationSteps: 2,
    shape: 'circle',
    drawOutOfBound: false,
    hover: function(item, dimension, event) {
      // Optional: could add tooltip
    },
    click: function(item) {
      alert(`Topic: ${item[0]}, Count: ${item[1]}`);
    }
  });
}

function drawCharts(data) {
  const callsOverTime = aggregateCallsOverTime(data);
  Plotly.newPlot('callsOverTime', [{
    x: callsOverTime.dates,
    y: callsOverTime.values,
    type: 'scatter',
    mode: 'lines+markers',
    line: {color: '#1f77b4', width: 3},
    marker: {size: 6}
  }], {
    title: 'Calls Over Time',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    legend: {orientation: 'h', y: -0.3}
  });

  const avgDuration = aggregateAverageCallDurationByAgent(data);
  Plotly.newPlot('averageCallDurationByAgent', [{
    x: avgDuration.agents,
    y: avgDuration.averages,
    type: 'bar',
    marker: {color: '#ff7f0e'}
  }], {
    title: 'Average Call Duration by Agent (minutes)',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    legend: {orientation: 'h', y: -0.3}
  });

  const callsByAgent = aggregateCallsByAgent(data);
  Plotly.newPlot('callsByAgent', [{
    x: callsByAgent.agents,
    y: callsByAgent.values,
    type: 'bar',
    marker: {color: '#2ca02c'}
  }], {
    title: 'Calls by Agent',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    showlegend: false
  });

  const callsByTopic = aggregateCallsByTopic(data);
  Plotly.newPlot('callsByTopic', [{
    x: callsByTopic.topics,
    y: callsByTopic.values,
    type: 'bar',
    marker: {color: '#17becf'}
  }], {
    title: 'Calls by Topic',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    legend: {orientation: 'h', y: -0.3}
  });

  const callsByProduct = aggregateCallsByProduct(data);
  Plotly.newPlot('callsByProduct', [{
    x: callsByProduct.products,
    y: callsByProduct.values,
    type: 'bar',
    marker: {color: '#9467bd'}
  }], {
    title: 'Calls by Product',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    legend: {orientation: 'h', y: -0.3}
  });

  const callOutcomes = aggregateCallOutcomes(data);
  Plotly.newPlot('callOutcomes', [{
    x: callOutcomes.outcomes,
    y: callOutcomes.values,
    type: 'bar',
    marker: {color: '#d62728'}
  }], {
    title: 'Call Outcomes',
    xaxis: {showticklabels: true, title: ''},
    yaxis: {showticklabels: true, title: ''},
    legend: {orientation: 'h', y: -0.3}
  });

  const sentimentCounts = aggregateSentiment(data);
  Plotly.newPlot('sentimentAnalysis', [{
    values: [sentimentCounts.Positive, sentimentCounts.Neutral, sentimentCounts.Negative],
    labels: ['Positive', 'Neutral', 'Negative'],
    type: 'pie',
    marker: {colors: ['#2ca02c', '#ffcc00', '#d62728']}
  }], {
    title: 'Sentiment Analysis',
    legend: {orientation: 'h', y: -0.3}
  });

  drawWordCloud(data);
}

function generateTakeaways(data) {
  const takeawaysList = document.getElementById('takeaways-list');
  takeawaysList.innerHTML = '';

  // Total calls
  const totalCalls = data.length;

  // Top 3 agents by call volume
  const callsByAgent = aggregateCallsByAgent(data);
  const topAgents = callsByAgent.agents
    .map((agent, i) => ({agent, count: callsByAgent.values[i]}))
    .sort((a,b) => b.count - a.count)
    .slice(0,3);

  // Top 3 topics
  const callsByTopic = aggregateCallsByTopic(data);
  const topTopics = callsByTopic.topics
    .map((topic, i) => ({topic, count: callsByTopic.values[i]}))
    .sort((a,b) => b.count - a.count)
    .slice(0,3);

  // Sentiment summary
  const sentimentCounts = aggregateSentiment(data);
  const totalSentiments = sentimentCounts.Positive + sentimentCounts.Neutral + sentimentCounts.Negative;
  const posPct = totalSentiments ? ((sentimentCounts.Positive / totalSentiments)*100).toFixed(1) : 0;
  const negPct = totalSentiments ? ((sentimentCounts.Negative / totalSentiments)*100).toFixed(1) : 0;

  // Recommendations - basic example based on sentiment and volume
  const recommendations = [];
  if (negPct > 20) {
    recommendations.push("High negative sentiment detected; consider additional agent training or resource updates.");
  } else {
    recommendations.push("Sentiment is generally positive; maintain current support quality.");
  }
  if (topTopics.length > 0) {
    recommendations.push(`Focus resources on top call topics: ${topTopics.map(t => t.topic).join(', ')}.`);
  }
  if (topAgents.length > 0) {
    recommendations.push(`Monitor workload of top agents: ${topAgents.map(a => a.agent).join(', ')} to ensure balanced support.`);
  }

  // Add to list
  [
    `Total calls in selected period: ${totalCalls}`,
    `Top agents by volume: ${topAgents.map(a => `${a.agent} (${a.count})`).join(', ')}`,
    `Top call topics: ${topTopics.map(t => `${t.topic} (${t.count})`).join(', ')}`,
    `Positive sentiment: ${posPct}%, Negative sentiment: ${negPct}%`
  ].forEach(text => {
    const li = document.createElement('li');
    li.textContent = text;
    takeawaysList.appendChild(li);
  });

  if(recommendations.length) {
    const hr = document.createElement('hr');
    hr.style.margin = "12px 0";
    takeawaysList.appendChild(hr);
    const recHeader = document.createElement('li');
    recHeader.style.fontWeight = "700";
    recHeader.textContent = "Recommendations:";
    takeawaysList.appendChild(recHeader);
    recommendations.forEach(rec => {
      const li = document.createElement('li');
      li.textContent = rec;
      li.style.marginLeft = "15px";
      takeawaysList.appendChild(li);
    });
  }
}

let dashboardData = [];
const fileInput = document.getElementById('fileInput');
const filtersDiv = document.getElementById('filters');
const chartsDiv = document.getElementById('charts');
const takeawaysDiv = document.getElementById('takeaways');

function applyFiltersAndUpdate() {
  const filters = {
    agent: document.getElementById('agentFilter').value,
    lh: document.getElementById('lhFilter').value,
    topic: document.getElementById('topicFilter').value,
    dateFrom: document.getElementById('dateFrom').value ? new Date(document.getElementById('dateFrom').value) : null,
    dateTo: document.getElementById('dateTo').value ? new Date(document.getElementById('dateTo').value) : null
  };
  // Adjust dateTo to end of day
  if(filters.dateTo) {
    filters.dateTo.setHours(23,59,59,999);
  }
  const filteredData = filterData(dashboardData, filters);
  drawCharts(filteredData);
  generateTakeaways(filteredData);
  takeawaysDiv.style.display = filteredData.length ? 'block' : 'none';
}

fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt) {
    try {
      const json = JSON.parse(evt.target.result);
      if(!Array.isArray(json)) {
        alert("Invalid JSON format: Expected an array of records.");
        return;
      }
      dashboardData = json;
      populateFilterOptions(dashboardData);
      filtersDiv.style.display = 'block';
      chartsDiv.style.display = 'flex';
      applyFiltersAndUpdate();
    } catch(err) {
      alert("Error parsing JSON: " + err.message);
    }
  };
  reader.readAsText(file);
});

['agentFilter','lhFilter','topicFilter','dateFrom','dateTo'].forEach(id => {
  document.getElementById(id).addEventListener('change', applyFiltersAndUpdate);
});
</script>

</body>
</html>
